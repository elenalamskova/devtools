Gradle-проект ProgressDemo
[![Java CI with Checkstyle and JaCoCo](https://github.com/elenalamskova/devtools/actions/workflows/ci.yml/badge.svg)](https://github.com/elenalamskova/devtools/actions/workflows/ci.yml)
- Quick Start:
  JDK25; Gradle 9.2.0
  ./gradlew run (запустить приложение)
  ./gradlew test (запустить все тесты)
- Описание пакета
  package ru.mentee.power пакет в репозитории devtools. в этом пакете хранится класс ProgressDemo.java и record-class MenteeProgress.java + тестовый класс MenteeProgressTest.java вынесен отдельно, но тоже имеет отношение в этому пакету.
  Основные классы и тестовые хранятся в папке build, но первые - в папке main, а вторые - в папке test.
  Пакет позволяет четко ориентироваться в именах переменных и их описанных связях.
- таблица полей MenteeProgress
  record MenteeProgress(String menteeName, int sprintNumber, int plannedHoursPerWeek)

| название            | тип переменной | наполнение    |
| ------------------- | -------------- | ------------- |
| menteeName          | String         | имя студента  |
| sprintNumber        | int            | номер спринта |
| plannedHoursPerWeek | int            | время спринта |
- ссылка на урок https://mentee-power.xl.ru/learn/MCIneBj4KkyH-GIRCspFvA/theory
- Git-локальный цикл
    git init
    создание шаблонов (templates)+.gitignore+README.md
    git add (имя файла или несколько через пробел)
    git commit -m "message"
    git status
    git push -u origin (название ветки нововведения)

- Правило веток: feature/DVT‑X - называем ветки по номеру урока; шаблон записи в названии
- Сценарий ручной проверки DVT-6
## Сценарий ручной проверки DVT-6

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До:    import java.util.List; import java.util.ArrayList; import java.io.File;
После: import java.io.File; import java.util.ArrayList; import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used

# CI-пайплайн настроен"
new workflow file создан по образцу:

name: <Ваше_название>

on:
push:
branches:
- <ветка_1>
- '<паттерн_feature>'
pull_request:
branches:
- <ветка_master>

jobs:
<имя_job>:
runs-on: <операционная_система>

       steps:
         - name: <Описание_шага_1>
           uses: actions/checkout@v4

         - name: <Описание_шага_2>
           uses: actions/setup-java@v4
           with:
             distribution: '<дистрибутив>'
             java-version: '<версия>'

         - name: <Описание_шага_3>
           run: <команда_checkstyle>

         - name: <Описание_шага_4>
           run: <команда_тесты>

         - name: <Описание_шага_5>
           run: <команда_сборка>

## Code Review Checklist

Используйте этот чеклист для само-ревью перед запросом ревью у ментора:

### Функциональность
- [ ] Код решает поставленную задачу полностью
- [ ] Обработаны граничные случаи (null, пустые данные, экстремальные значения)
- [ ] Обработка ошибок реализована корректно

### Тесты
- [ ] Добавлены тесты для нового функционала (или обновлены существующие)
- [ ] Все тесты проходят локально: `./gradlew test`
- [ ] Покрыты позитивные и негативные сценарии
- [ ] JaCoCo coverage ≥ 80% для нового кода

### Читаемость и стиль
- [ ] Имена переменных, методов и классов отражают назначение
- [ ] Нет дублирования кода (DRY principle)
- [ ] Checkstyle проходит без ошибок: `./gradlew checkstyleMain`
- [ ] Нет закомментированного кода или отладочного вывода (`System.out.println`)

### Документация
- [ ] README обновлён (если добавлена новая функциональность)
- [ ] Публичные методы имеют JavaDoc (если применимо)
- [ ] Примеры использования актуальны
- [ ] Runbook обновлён (если изменились команды запуска/проверки)

### Производительность и безопасность
- [ ] Нет очевидных проблем производительности
- [ ] Нет хардкода паролей, токенов или конфиденциальных данных


## Примеры Code Review комментариев

### Хорошие комментарии (конструктивные)

Шаблон конструктивного комментария:

**Проблема:** [Конкретное описание проблемы с указанием строки]
**Почему это важно:** [Объяснение последствий]
**Предложение:** [Как исправить или альтернативный подход]
**Пример:**

// Предлагаемый код


**Пример 1:**

**Проблема:** Метод `calculateDiscount` (строка 45) имеет 3 вложенных if-else и 40 строк.
**Почему это важно:** Сложная логика плохо тестируется и тяжело поддерживается.
**Предложение:** Вынести каждое условие в отдельный метод (например, `isEligibleForBonusDiscount()`)
и использовать паттерн Strategy для разных типов скидок.



**Пример 2:**

**Проблема:** Тест `testProcessOrder` (строка 78) проверяет только успешный сценарий.
**Почему это важно:** Не проверена обработка ошибок при недостаточном балансе.
**Предложение:** Добавить тест `testProcessOrder_InsufficientBalance_ThrowsException()`
с использованием `assertThatThrownBy()`.



### Плохие комментарии (неконструктивные)

**Пример 1:**

Этот код ужасен, полностью переписать.


**Почему плохо:** Нет конкретики (что именно плохо), нет предложения (как исправить),
токсичный тон (демотивирует автора).

**Пример 2:**

Здесь лучше использовать Stream API.


**Почему плохо:** Нет объяснения почему лучше, нет примера как переписать,
неясно какую проблему это решает.

## Результаты само-ревью к заданию DVT-9:
1. намеренно созданы ошибки: 
лишний отладочный вывод и закомментированное действие в файле src/main/java/ru/mentee/power/ProgressDemo.java (строки 19-22)
нужно исправить
   **Проблема:** Оставлен `System.out.println("Debug: starting loop")`
   **Почему важно:** Отладочный вывод замусоривает логи production-приложения и создаёт впечатление небрежности.
   **Исправление:** Удалить строку

**Проблема:** Закомментирована строка 
**Почему важно:** Закомментированный код создаёт путаницу: непонятно зачем он сохранён и актуален ли.
Если нужна история изменений — она в Git.
**Исправление:** Удалить закомментированный код.


2. симитированные ошибки удалены; исправленные файлы отправлены в гитхаб.
3. Финальное само-ревью:
3.1 Создан чеклист Code Review в README.md
3.2 Созданы проблемы для тренировки: решены и описаны в само-ревью
3.3 Оценка проекта:
- Функциональность: чеклист работает
- тесты: запуск ./gradlew test; ./gradlew checkstyleMain - проходят
- CI: проходит (GitHub Actions badge green)
- Документация: дополнена

## Информационный поиск — результаты DVT-11

### Запросы и источники

| № | Запрос              | Операторы                                                         | Официальный                                                                | Альтернатива                                                                        | Статус | Дата       |                                |

| 1 | Lombok Gradle Short | site:search.maven.org "lombok" OR site:mvnrepository.com "lombok" | search.maven.org/.../1.18.42 (pkg:maven/org.projectlombok/lombok@1.18.42)  | mvnrepository.com/.../1.18.42                                                       | 200 OK | 30.12.2025 |
| 2 | Java Stream API     | site:docs.oracle.com "stream api" intitle:api java 25             | docs.oracle.com/.../package-summary.html                                   | blog.jetbrains.com/.../easy-hacks-how-to-use-java-streams-for-working-with-data/    | 200 OK | 30.12.2025 |
| 3 | IntelliJ keymap     | site:www.jetbrains.com/help "keymap" "intellij idea"              | jetbrains.com/help/idea/settings-keymap.html                               | Help → Keymap Reference (IDE)                                                       | 200 OK | 30.12.2025 |

### AI-промпты и сравнение ассистентов

#### Промпт 1: План решения

Задача: на Java 25 реализовать тело метода calculateTotalProgress, используя цикл while для перебора массива. Цикл должен обработать минимум 3 элемента
Контекст: уже имеется рекорд Mentee с полями String name,
String city,
String goal,
int completedLessons,
int totalLessons
Ограничения: Используйте геттеры record'а: mentees[index].completedLessons() и mentees[index].totalLessons()
Ожидаемый результат: план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам
Критерии успеха: валидация отклоняет пустые строки, строки без @, строки без точки после @

**AI-1 ([DeepSeek]):**
План реализации
Инициализация переменных-аккумуляторов.
Создайте две целочисленные переменные, например, totalCompleted и totalAllLessons. Обе должны быть инициализированы нулем. Они будут накапливать сумму пройденных и общее количество уроков по всем обработанным ментам.
Подготовка цикла while.
Создайте переменную-счетчик (например, index) и установите ее в 0. Она будет контролировать доступ к элементам массива mentees и условие выхода из цикла.
Определите условие продолжения цикла: index < mentees.length. Это гарантирует, что мы не выйдем за границы массива.
Организация внутренней логики цикла.
Валидация данных: Внутри цикла, прежде чем использовать данные мента, проверьте, что оба значения — completedLessons и totalLessons — полученные через геттеры, больше или равны нулю, а также что totalLessons не равен нулю (во избежание деления на ноль на следующем шаге). Если данные невалидны, можно либо пропустить этого мента (используя index++ и continue), либо обработать ошибку, в зависимости от требований.
Накопление сумм: Если данные валидны, прибавьте значение completedLessons() текущего мента к totalCompleted, а значение totalLessons() — к totalAllLessons.
Увеличение счетчика и проверка на минимальное количество.
В конце каждой итерации обязательно увеличивайте счетчик index на единицу (index++), чтобы цикл двигался к следующему элементу и в конечном итоге завершился.
Продумайте дополнительную логику для гарантии обработки минимум 3 элементов. Если в массиве меньше 3 элементов, цикл while по своему базовому условию (index < mentees.length) завершится раньше. Вам нужно решить, как поступить в этом случае: вернуть 0, выбросить исключение или считать прогресс только по имеющимся. Это бизнес-логика, которую стоит уточнить.
Расчет и возврат итогового результата.
После завершения цикла (когда счетчик index достиг длины массива), рассчитайте общий прогресс.
Чтобы избежать деления на ноль, проверьте, что totalAllLessons > 0.
Рассчитайте результат как (double) totalCompleted / totalAllLessons. Приведение типа double для totalCompleted важно, чтобы результат деления был дробным, а не целочисленным.
Верните полученное значение. Возвращаемый тип метода, скорее всего, должен быть double.
Почему именно так?
Цикл while: Использование цикла while с явным счетчиком дает полный контроль над итерацией и наглядно демонстрирует процесс перебора массива "вручную", что соответствует условию задачи.
Аккумуляторы (totalCompleted, totalAllLessons): Прогресс — это общая доля выполненных уроков от общего их числа. Для его расчета необходимо сначала получить обе суммы по всему массиву. Попытка усреднить проценты каждого мента даст математически неверный результат.
Валидация внутри цикла: Данные могут прийти с ошибками (например, отрицательное количество уроков). Их проверка на месте предотвратит порчу итоговых сумм некорректными значениями и возможные runtime-исключения (деление на ноль).
Приведение к double: Поскольку результат — это процент (доля от 0.0 до 1.0 или от 0% до 100%), необходимо использовать деление с плавающей точкой. Деление целых чисел в Java даст целый результат (например, 3/4 = 0), что неверно.
Минимум 3 элемента: Условие задачи требует обработки минимум 3 элементов. Базовый цикл while этого не гарантирует, поэтому требуется дополнительная логика для обработки пограничного случая (маленький массив), что делает решение более надежным и завершенным.

**AI-2 ([Perplexity]):**
Шаги плана
Инициализируйте переменную-сумматор прогресса (double totalProgress = 0.0) и индекс для цикла (int i = 0) перед циклом while.
В цикле while проверяйте условие i < mentees.length && i < 3 (чтобы гарантировать минимум 3 итерации, но не превысить размер массива), внутри вычисляйте прогресс для текущего элемента как (mentees[i].completedLessons() / (double) mentees[i].totalLessons()) * 100 и добавляйте к сумматору.
Увеличивайте индекс i++ в теле цикла после вычисления и инкрементируйте сумматор.
После выхода из цикла верните totalProgress / количество обработанных элементов (используйте отдельную переменную-счетчик итераций, начиная с 0 и увеличивая в цикле).
Почему именно так
Цикл while идеален для строгого контроля итераций с условием минимум 3 элементов: он позволяет гибко управлять логикой (проверка длины массива + фиксированный минимум), избегая for-each (который не дает прямого индекса) или for с фиксированным числом (игнорирующим размер массива).
Формула прогресса (completedLessons / totalLessons * 100) стандартна для процентов выполнения, с приведением к double для точности деления, что предотвращает целочисленное округление вниз.
Суммирование и усреднение обеспечивают общий totalProgress по массиву, а счетчик итераций гарантирует корректное деление даже при обработке ровно 3 элементов.
Валидация критериев
Пустые строки или без @/точки отклоняются на этапе парсинга входных данных (не в этом методе), так как calculateTotalProgress работает только с готовым массивом Mentee-рекордов.

**Сравнение:**
1 ответ более подробный; предлагается +- одна логика
#### Промпт 2: Проверка кода

**Код для проверки:**

package ru.mentee.power.devtools.student;

import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class StudentListTest {

    @Test
    void addStudentIncreasesSize() {
        StudentList list = new StudentList();
        Student student = new Student("Иван", "Пермь");

        list.addStudent(student);

        assertEquals(1, list.getStudentsByCity("Пермь").size());
    }

    @Test
    void getStudentsByCityFiltersCorrectly() {
        StudentList list = new StudentList();
        list.addStudent(new Student("Иван", "Пермь"));
        list.addStudent(new Student("Петр", "Москва"));

        List<Student> permStudents = list.getStudentsByCity("Пермь");

        assertEquals(1, permStudents.size());
        assertEquals("Иван", permStudents.get(0).name());
    }
    @Test
    void addStudentShouldIgnoreNull() {
        StudentList list = new StudentList();

        list.addStudent(null);

        assertEquals(0, list.getStudentsByCity("Пермь").size());
    }
}
**Что проверить:**
1. Логические ошибки
2. Соответствие Code Conventions
3. Производительность

**AI-1 ([DeepSeek]):**
1. Логические ошибки и полнота тестов
   Существующие проблемы:

Некорректный тест addStudentIncreasesSize: Этот тест проверяет не то, что заявлено в названии. Он проверяет размер отфильтрованного списка по городу, а не общий размер списка студентов. Название метода вводит в заблуждение.

Как обнаружить: Добавить студента из другого города и проверить list.getStudentsByCity("Пермь").size() — тест провалится, хотя студент был добавлен.

Решение: Нужен отдельный метод для получения общего количества студентов или проверка размера внутреннего списка, если такой метод существует.

Неполное покрытие getStudentsByCity:

Пустой результат: Не проверен случай, когда в городе нет студентов (должен возвращаться пустой список, а не null).

Регистр букв: Не проверена чувствительность к регистру. Если в StudentList сравнение регистрозависимое, поиск по "пермь" вместо "Пермь" вернет пустой список.

Повторяющиеся города: Не проверено, что метод корректно возвращает несколько студентов из одного города.

Неполное покрытие addStudent:

Дубликаты: Не проверено, как ведет себя список при добавлении студента с одинаковыми именем и городом (разрешает ли он дубликаты?).

"Пустой" студент: Не проверены студенты с null-значениями в полях name или city, если такие допустимы конструктором Student.

Дополнительные кейсы, которые стоит проверить:

Удаление студента (если такой функционал есть).

Поиск по несуществующему городу.

Итерация по всем студентам.

2. Соответствие Code Conventions
   Нарушения и рекомендации:

Именование тестовых методов (основная проблема):

Текущие имена: addStudentIncreasesSize, getStudentsByCityFiltersCorrectly.

Рекомендуемый стандарт: Имена тестов должны быть описательными и часто используют шаблон should_When или methodName_Scenario_ExpectedResult.

Предложение:

addStudent_shouldIncreaseTotalSize (после исправления логики)

getStudentsByCity_shouldReturnFilteredList

addStudent_shouldIgnoreNullStudent

Форматирование и структура:

Отступы и пробелы выглядят корректно.

Разделение логических блоков пустыми строками улучшило бы читаемость.

Аннотация @Test на отдельной строке для каждого метода — правильно.

Локализация:

Использование кириллицы в тестовых данных допустимо для наглядности, но в реальном проекте нужно убедиться, что это не вызывает проблем с кодировкой.

Имена переменных на английском — правильно.

3. Производительность
Потенциальные проблемы в тестируемом коде (который мы не видим, но можем предположить):

Алгоритмическая сложность getStudentsByCity:

Если реализация использует линейный поиск (for-цикл по всем студентам), то сложность O(n). Это нормально для небольших списков.

Потенциальная проблема: Если StudentList будет использоваться с тысячами студентов и частыми вызовами getStudentsByCity, производительность станет узким местом.

Что проверить в реализации: Используется ли кэширование или индекс (например, Map<String, List<Student>>) для группировки студентов по городу.

Производительность тестов:

Тесты изолированы и быстры, проблем нет.

Если бы в setUp создавались тяжелые ресурсы, нужно было бы использовать @BeforeEach правильно.

Память:

Если getStudentsByCity возвращает новую коллекцию при каждом вызове (что вероятно), это создает дополнительные объекты. Для больших списков это может привести к нагрузке на GC.

Альтернатива: Возвращать неизменяемое представление или использовать поток (stream).

Резюме рекомендаций:
Исправить тест addStudentIncreasesSize, чтобы он проверял общее количество студентов.

Переименовать тестовые методы согласно конвенциям.

Дополнить тестовое покрытие:

getStudentsByCity_shouldReturnEmptyListForUnknownCity

getStudentsByCity_shouldBeCaseSensitive (или CaseInsensitive, в зависимости от требований)

addStudent_shouldAllowDuplicateStudents (или наоборот, если дубликаты запрещены)

Проанализировать реализацию StudentList на предмет эффективности getStudentsByCity при больших объемах данных.

Добавить тест на производительность (стресс-тест) при необходимости, если класс будет работать с большими списками.

Что проверить в реализации StudentList:

Как хранятся студенты (какая структура данных).

Как реализован getStudentsByCity (линейный поиск или хэш-таблица).

Возвращает ли метод новую коллекцию или представление.
**AI-2 ([Perplexity]):**
Тесты проверяют базовую функциональность StudentList, но содержат логические несоответствия и нарушения конвенций. Они соответствуют минимальным требованиям JUnit, однако упускают ключевые сценарии и оптимизации.
Логические ошибки
Тест addStudentShouldIgnoreNull проверяет getStudentsByCity("Пермь") вместо общего размера списка, что некорректно: null может добавляться без города "Пермь", тест пройдет случайно.
Отсутствует проверка поведения при пустом списке в getStudentsByCityFiltersCorrectly (должен возвращать пустой список).
Нет тестов на case-insensitive фильтрацию городов, дубликаты студентов или большие города (например, "пермь" vs "Пермь").
Code Conventions
Названия методов смешанные: addStudentIncreasesSize (Behavior) vs getStudentsByCityFiltersCorrectly (Method+Behavior) — используйте единый стиль "should[Method][ExpectedBehavior]".
Магическая строка "Пермь" в нескольких тестах — вынесите в константу CITY_PERM = "Пермь". 
Лишние пустые строки между импортами и классом нарушают стандартный формат (2 пустые строки после package/import). 
Отсутствует @DisplayName для читаемости в IDE/отчетах.
Производительность
Тесты оптимальны: создают минимум объектов, без циклов или внешних зависимостей, выполняются за микросекунды.
Для масштаба добавьте @Repeated(100) на addStudentIncreasesSize, чтобы нагрузить addStudent, но текущий объем достаточен для unit-тестов.
Рекомендация: используйте @ParameterizedTest для getStudentsByCity с массивом городов, снижая дублирование кода без потери скорости.

**Сравнение:**
ответ №1 более подробный и "в лоб"; 2 ответ более локаничный и "понятный"